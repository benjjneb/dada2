<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>DADA2 Pipeline Tutorial (1.16)</title>

<script src="site_libs/header-attrs-2.18.1/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />
<link href="site_libs/ionicons-2.0.1/css/ionicons.min.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>









<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->




</head>

<body>


<div class="container-fluid main-container">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">dada2</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="dada-installation.html">Install</a>
</li>
<li>
  <a href="tutorial.html">Tutorial</a>
</li>
<li>
  <a href="bigdata.html">Big Data</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    <span class="fa fa-gear"></span>
     
    Documentation
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="https://www.bioconductor.org/packages/release/bioc/manuals/dada2/man/dada2.pdf">Manual</a>
    </li>
    <li>
      <a href="assign.html">Taxonomy</a>
    </li>
    <li>
      <a href="training.html">Taxonomic References</a>
    </li>
    <li>
      <a href="pool.html">Pooling</a>
    </li>
    <li>
      <a href="faq.html">FAQ</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    <span class="fa fa-gear"></span>
     
    Evaluation
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="http://dx.doi.org/10.1038/nmeth.3869">DADA2 Manuscript</a>
    </li>
    <li>
      <a href="http://dx.doi.org/10.1038/ismej.2017.119">Exact Sequence Variants</a>
    </li>
    <li>
      <a href="https://doi.org/10.1101/392332">PacBio Long Reads</a>
    </li>
    <li>
      <a href="SMBS_DADA2.pdf">Symposium Slides</a>
    </li>
    <li>
      <a href="SotA.html">Benchmarking</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://www.twitter.com/bejcal">
    <span class="ion ion-social-twitter"></span>
     
  </a>
</li>
<li>
  <a href="https://github.com/benjjneb/dada2/issues">
    <span class="fa fa-question fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="https://github.com/benjjneb/dada2">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">DADA2 Pipeline Tutorial (1.16)</h1>

</div>


<p>Here we walk through version 1.16 of the DADA2 pipeline on a small multi-sample dataset. Our starting point is a set of Illumina-sequenced paired-end fastq files that have been split (or “demultiplexed”) by sample and from which the barcodes/adapters have already been removed. The end product is an <strong>amplicon sequence variant (ASV) table</strong>, a higher-resolution analogue of the traditional OTU table, which records the number of times each <a href="https://www.nature.com/articles/ismej2017119">exact amplicon sequence variant</a> was observed in each sample. We also assign taxonomy to the output sequences, and demonstrate how the data can be imported into the popular <a href="https://joey711.github.io/phyloseq/">phyloseq</a> R package for the analysis of microbiome data.</p>
<hr />
<div id="starting-point" class="section level1">
<h1>Starting point</h1>
<p>This workflow assumes that your sequencing data meets certain criteria:</p>
<ul>
<li>Samples have been demultiplexed, i.e. split into individual per-sample fastq files.</li>
<li>Non-biological nucleotides have been removed, e.g. primers, adapters, linkers, etc.</li>
<li>If paired-end sequencing data, the forward and reverse fastq files contain reads in matched order.</li>
</ul>
<p>If these criteria are not true for your data (<strong>are you sure there aren’t any primers hanging around?</strong>) you need to remedy those issues before beginning this workflow. See <a href="faq.html">the FAQ</a> for recommendations for some common issues.</p>
</div>
<div id="getting-ready" class="section level1">
<h1>Getting ready</h1>
<p>First we load the <code>dada2</code> package. If you don’t already have it, see the <a href="dada-installation.html">dada2 installation instructions</a>.</p>
<pre class="r"><code>library(dada2); packageVersion(&quot;dada2&quot;)</code></pre>
<pre><code>## [1] &#39;1.25.2&#39;</code></pre>
<p><em>Older versions of this workflow associated with previous release versions of the dada2 R package are also available: <a href="tutorial_1_6.html">1.6</a>, <a href="tutorial_1_8.html">1.8</a>, <a href="tutorial_1_12.html">1.12</a>, .</em></p>
<p>The data we will work with are the same as those used in the <a href="https://mothur.org/wiki/miseq_sop/">mothur MiSeq SOP</a>. To follow along, download the <a href="https://mothur.s3.us-east-2.amazonaws.com/wiki/miseqsopdata.zip">example data</a> and unzip. These fastq files were generated by 2x250 Illumina Miseq amplicon sequencing of the V4 region of the 16S rRNA gene from gut samples collected longitudinally from a mouse post-weaning. For now just consider them paired-end fastq files to be processed. Define the following path variable so that it points to the extracted directory on <strong>your</strong> machine:</p>
<pre class="r"><code>path &lt;- &quot;~/MiSeq_SOP&quot; # CHANGE ME to the directory containing the fastq files after unzipping.
list.files(path)</code></pre>
<pre><code>##  [1] &quot;F3D0_S188_L001_R1_001.fastq&quot;   &quot;F3D0_S188_L001_R2_001.fastq&quot;  
##  [3] &quot;F3D1_S189_L001_R1_001.fastq&quot;   &quot;F3D1_S189_L001_R2_001.fastq&quot;  
##  [5] &quot;F3D141_S207_L001_R1_001.fastq&quot; &quot;F3D141_S207_L001_R2_001.fastq&quot;
##  [7] &quot;F3D142_S208_L001_R1_001.fastq&quot; &quot;F3D142_S208_L001_R2_001.fastq&quot;
##  [9] &quot;F3D143_S209_L001_R1_001.fastq&quot; &quot;F3D143_S209_L001_R2_001.fastq&quot;
## [11] &quot;F3D144_S210_L001_R1_001.fastq&quot; &quot;F3D144_S210_L001_R2_001.fastq&quot;
## [13] &quot;F3D145_S211_L001_R1_001.fastq&quot; &quot;F3D145_S211_L001_R2_001.fastq&quot;
## [15] &quot;F3D146_S212_L001_R1_001.fastq&quot; &quot;F3D146_S212_L001_R2_001.fastq&quot;
## [17] &quot;F3D147_S213_L001_R1_001.fastq&quot; &quot;F3D147_S213_L001_R2_001.fastq&quot;
## [19] &quot;F3D148_S214_L001_R1_001.fastq&quot; &quot;F3D148_S214_L001_R2_001.fastq&quot;
## [21] &quot;F3D149_S215_L001_R1_001.fastq&quot; &quot;F3D149_S215_L001_R2_001.fastq&quot;
## [23] &quot;F3D150_S216_L001_R1_001.fastq&quot; &quot;F3D150_S216_L001_R2_001.fastq&quot;
## [25] &quot;F3D2_S190_L001_R1_001.fastq&quot;   &quot;F3D2_S190_L001_R2_001.fastq&quot;  
## [27] &quot;F3D3_S191_L001_R1_001.fastq&quot;   &quot;F3D3_S191_L001_R2_001.fastq&quot;  
## [29] &quot;F3D5_S193_L001_R1_001.fastq&quot;   &quot;F3D5_S193_L001_R2_001.fastq&quot;  
## [31] &quot;F3D6_S194_L001_R1_001.fastq&quot;   &quot;F3D6_S194_L001_R2_001.fastq&quot;  
## [33] &quot;F3D7_S195_L001_R1_001.fastq&quot;   &quot;F3D7_S195_L001_R2_001.fastq&quot;  
## [35] &quot;F3D8_S196_L001_R1_001.fastq&quot;   &quot;F3D8_S196_L001_R2_001.fastq&quot;  
## [37] &quot;F3D9_S197_L001_R1_001.fastq&quot;   &quot;F3D9_S197_L001_R2_001.fastq&quot;  
## [39] &quot;filtered&quot;                      &quot;HMP_MOCK.v35.fasta&quot;           
## [41] &quot;Mock_S280_L001_R1_001.fastq&quot;   &quot;Mock_S280_L001_R2_001.fastq&quot;  
## [43] &quot;mouse.dpw.metadata&quot;            &quot;mouse.time.design&quot;            
## [45] &quot;stability.batch&quot;               &quot;stability.files&quot;</code></pre>
<p>If the package successfully loaded and your listed files match those here, you are ready to go through the DADA2 pipeline.</p>
<p>Now we read in the names of the fastq files, and perform some string manipulation to get matched lists of the forward and reverse fastq files.</p>
<pre class="r"><code># Forward and reverse fastq filenames have format: SAMPLENAME_R1_001.fastq and SAMPLENAME_R2_001.fastq
fnFs &lt;- sort(list.files(path, pattern=&quot;_R1_001.fastq&quot;, full.names = TRUE))
fnRs &lt;- sort(list.files(path, pattern=&quot;_R2_001.fastq&quot;, full.names = TRUE))
# Extract sample names, assuming filenames have format: SAMPLENAME_XXX.fastq
sample.names &lt;- sapply(strsplit(basename(fnFs), &quot;_&quot;), `[`, 1)</code></pre>
<div style="border: 1px solid red;padding: 5px;background-color: #fff6f6;">
<strong><span style="color:red">Considerations for your own data:</span></strong> The string manipulations may have to be modified if your filename format is different.
</div>
<p> </p>
</div>
<div id="inspect-read-quality-profiles" class="section level1">
<h1>Inspect read quality profiles</h1>
<p>We start by visualizing the quality profiles of the forward reads:</p>
<pre class="r"><code>plotQualityProfile(fnFs[1:2])</code></pre>
<p><img src="tutorial_files/figure-html/see-quality-F-1.png" width="672" /></p>
<p>In gray-scale is a heat map of the frequency of each quality score at each base position. The mean quality score at each position is shown by the green line, and the quartiles of the quality score distribution by the orange lines. The red line shows the scaled proportion of reads that extend to at least that position (this is more useful for other sequencing technologies, as Illumina reads are typically all the same length, hence the flat red line).</p>
<p>The forward reads are good quality. We generally advise trimming the last few nucleotides to avoid less well-controlled errors that can arise there. These quality profiles do not suggest that any additional trimming is needed. We will truncate the forward reads at position 240 (trimming the last 10 nucleotides).</p>
<p>Now we visualize the quality profile of the reverse reads:</p>
<pre class="r"><code>plotQualityProfile(fnRs[1:2])</code></pre>
<p><img src="tutorial_files/figure-html/see-quality-R-1.png" width="672" /></p>
<p>The reverse reads are of significantly worse quality, especially at the end, which is common in Illumina sequencing. This isn’t too worrisome, as DADA2 incorporates quality information into its error model which makes the algorithm <a href="https://twitter.com/bejcal/status/771010634074820608">robust to lower quality sequence</a>, but trimming as the average qualities crash will improve the algorithm’s sensitivity to rare sequence variants. Based on these profiles, we will truncate the reverse reads at position 160 where the quality distribution crashes.</p>
<div style="border: 1px solid red;padding: 5px;background-color: #fff6f6;">
<strong><span style="color:red">Considerations for your own data:</span></strong> <strong>Your reads must still overlap after truncation in order to merge them later!</strong> The tutorial is using 2x250 V4 sequence data, so the forward and reverse reads almost completely overlap and our trimming can be completely guided by the quality scores. If you are using a less-overlapping primer set, like V1-V2 or V3-V4, your <code>truncLen</code> must be large enough to maintain <code>20 + biological.length.variation</code> nucleotides of overlap between them.
</div>
<p> </p>
</div>
<div id="filter-and-trim" class="section level1">
<h1>Filter and trim</h1>
<p>Assign the filenames for the filtered fastq.gz files.</p>
<pre class="r"><code># Place filtered files in filtered/ subdirectory
filtFs &lt;- file.path(path, &quot;filtered&quot;, paste0(sample.names, &quot;_F_filt.fastq.gz&quot;))
filtRs &lt;- file.path(path, &quot;filtered&quot;, paste0(sample.names, &quot;_R_filt.fastq.gz&quot;))
names(filtFs) &lt;- sample.names
names(filtRs) &lt;- sample.names</code></pre>
<p>We’ll use standard filtering parameters: <code>maxN=0</code> (DADA2 requires no Ns), <code>truncQ=2</code>, <code>rm.phix=TRUE</code> and <code>maxEE=2</code>. The <code>maxEE</code> parameter sets the maximum number of “expected errors” allowed in a read, which is <a href="https://academic.oup.com/bioinformatics/article/31/21/3476/194979">a better filter than simply averaging quality scores</a>.</p>
<pre class="r"><code>out &lt;- filterAndTrim(fnFs, filtFs, fnRs, filtRs, truncLen=c(240,160),
              maxN=0, maxEE=c(2,2), truncQ=2, rm.phix=TRUE,
              compress=TRUE, multithread=TRUE) # On Windows set multithread=FALSE
head(out)</code></pre>
<pre><code>##                               reads.in reads.out
## F3D0_S188_L001_R1_001.fastq       7793      7113
## F3D1_S189_L001_R1_001.fastq       5869      5299
## F3D141_S207_L001_R1_001.fastq     5958      5463
## F3D142_S208_L001_R1_001.fastq     3183      2914
## F3D143_S209_L001_R1_001.fastq     3178      2941
## F3D144_S210_L001_R1_001.fastq     4827      4312</code></pre>
<div style="border: 1px solid red;padding: 5px;background-color: #fff6f6;">
<strong><span style="color:red">Considerations for your own data:</span></strong> The standard filtering parameters are starting points, not set in stone. If you want to speed up downstream computation, consider tightening <code>maxEE</code>. If too few reads are passing the filter, consider relaxing <code>maxEE</code>, perhaps especially on the reverse reads (eg. <code>maxEE=c(2,5)</code>), and reducing the <code>truncLen</code> to remove low quality tails. Remember though, when choosing <code>truncLen</code> for paired-end reads you must maintain overlap after truncation in order to merge them later.
</div>
<div style="border: 1px solid red;padding: 5px;background-color: #fff6f6;margin-top: 15px;">
<strong><span style="color:red">Considerations for your own data:</span></strong> For ITS sequencing, it is usually undesirable to truncate reads to a fixed length due to the large length variation at that locus. That is OK, just leave out <code>truncLen</code>. See the <a href="ITS_workflow.html">DADA2 ITS workflow</a> for more information
</div>
<div style="border: 1px solid green;padding: 5px;background-color: #f0fff0;margin-top:30px;margin-bottom: 15px;">
<p><span style="color:green"><strong>Alternatives:</strong></span> <a href="https://www.zymoresearch.com/">Zymo Research</a> has recently developed a tool called Figaro that can help you choose DADA2 truncation length parameters: <a href="https://github.com/Zymo-Research/figaro#figaro" class="uri">https://github.com/Zymo-Research/figaro#figaro</a></p>
</div>
<p> </p>
</div>
<div id="learn-the-error-rates" class="section level1">
<h1>Learn the Error Rates</h1>
<p>The DADA2 algorithm makes use of a parametric error model (<code>err</code>) and every amplicon dataset has a different set of error rates. The <code>learnErrors</code> method learns this error model from the data, by alternating estimation of the error rates and inference of sample composition until they converge on a jointly consistent solution. As in many machine-learning problems, the algorithm must begin with an initial guess, for which the maximum possible error rates in this data are used (the error rates if only the most abundant sequence is correct and all the rest are errors).</p>
<p><em>The following runs in about 3 minutes on a 2013 Macbook Pro:</em></p>
<pre class="r"><code>errF &lt;- learnErrors(filtFs, multithread=TRUE)</code></pre>
<pre><code>## 33514080 total bases in 139642 reads from 20 samples will be used for learning the error rates.</code></pre>
<pre class="r"><code>errR &lt;- learnErrors(filtRs, multithread=TRUE)</code></pre>
<pre><code>## 22342720 total bases in 139642 reads from 20 samples will be used for learning the error rates.</code></pre>
<p>It is always worthwhile, as a sanity check if nothing else, to visualize the estimated error rates:</p>
<pre class="r"><code>plotErrors(errF, nominalQ=TRUE)</code></pre>
<p><img src="tutorial_files/figure-html/plot-errors-1.png" width="672" /></p>
<p>The error rates for each possible transition (A→C, A→G, …) are shown. Points are the observed error rates for each consensus quality score. The black line shows the estimated error rates after convergence of the machine-learning algorithm. The red line shows the error rates expected under the nominal definition of the Q-score. Here the estimated error rates (black line) are a good fit to the observed rates (points), and the error rates drop with increased quality as expected. Everything looks reasonable and we proceed with confidence.</p>
<p> </p>
</div>
<div id="sample-inference" class="section level1">
<h1>Sample Inference</h1>
<p>We are now ready to apply <a href="https://www.nature.com/articles/nmeth.3869#methods">the core sample inference algorithm</a> to the filtered and trimmed sequence data.</p>
<pre class="r"><code>dadaFs &lt;- dada(filtFs, err=errF, multithread=TRUE)</code></pre>
<pre><code>## Sample 1 - 7113 reads in 1979 unique sequences.
## Sample 2 - 5299 reads in 1639 unique sequences.
## Sample 3 - 5463 reads in 1477 unique sequences.
## Sample 4 - 2914 reads in 904 unique sequences.
## Sample 5 - 2941 reads in 939 unique sequences.
## Sample 6 - 4312 reads in 1267 unique sequences.
## Sample 7 - 6741 reads in 1756 unique sequences.
## Sample 8 - 4560 reads in 1438 unique sequences.
## Sample 9 - 15637 reads in 3590 unique sequences.
## Sample 10 - 11413 reads in 2762 unique sequences.
## Sample 11 - 12017 reads in 3021 unique sequences.
## Sample 12 - 5032 reads in 1566 unique sequences.
## Sample 13 - 18075 reads in 3707 unique sequences.
## Sample 14 - 6250 reads in 1479 unique sequences.
## Sample 15 - 4052 reads in 1195 unique sequences.
## Sample 16 - 7369 reads in 1832 unique sequences.
## Sample 17 - 4765 reads in 1183 unique sequences.
## Sample 18 - 4871 reads in 1382 unique sequences.
## Sample 19 - 6504 reads in 1709 unique sequences.
## Sample 20 - 4314 reads in 897 unique sequences.</code></pre>
<pre class="r"><code>dadaRs &lt;- dada(filtRs, err=errR, multithread=TRUE)</code></pre>
<pre><code>## Sample 1 - 7113 reads in 1660 unique sequences.
## Sample 2 - 5299 reads in 1349 unique sequences.
## Sample 3 - 5463 reads in 1335 unique sequences.
## Sample 4 - 2914 reads in 853 unique sequences.
## Sample 5 - 2941 reads in 880 unique sequences.
## Sample 6 - 4312 reads in 1286 unique sequences.
## Sample 7 - 6741 reads in 1803 unique sequences.
## Sample 8 - 4560 reads in 1265 unique sequences.
## Sample 9 - 15637 reads in 3414 unique sequences.
## Sample 10 - 11413 reads in 2522 unique sequences.
## Sample 11 - 12017 reads in 2771 unique sequences.
## Sample 12 - 5032 reads in 1415 unique sequences.
## Sample 13 - 18075 reads in 3290 unique sequences.
## Sample 14 - 6250 reads in 1390 unique sequences.
## Sample 15 - 4052 reads in 1134 unique sequences.
## Sample 16 - 7369 reads in 1635 unique sequences.
## Sample 17 - 4765 reads in 1084 unique sequences.
## Sample 18 - 4871 reads in 1161 unique sequences.
## Sample 19 - 6504 reads in 1502 unique sequences.
## Sample 20 - 4314 reads in 732 unique sequences.</code></pre>
<p>Inspecting the returned <code>dada-class</code> object:</p>
<pre class="r"><code>dadaFs[[1]]</code></pre>
<pre><code>## dada-class: object describing DADA2 denoising results
## 128 sequence variants were inferred from 1979 input unique sequences.
## Key parameters: OMEGA_A = 1e-40, OMEGA_C = 1e-40, BAND_SIZE = 16</code></pre>
<p>The DADA2 algorithm inferred 128 true sequence variants from the 1979 unique sequences in the first sample. There is much more to the <code>dada-class</code> return object than this (see <code>help("dada-class")</code> for some info), including multiple diagnostics about the quality of each denoised sequence variant, but that is beyond the scope of an introductory tutorial.</p>
<div style="border: 1px solid red;padding: 5px;background-color: #fff6f6;margin-top: 15px;">
<strong><span style="color:red">Considerations for your own data:</span></strong> DADA2 also supports 454 and Ion Torrent data, but <a href="faq.html#can-i-use-dada2-with-my-454-or-ion-torrent-data">we recommend some minor parameter changes</a> for those pyrosequencing technologies. The adventurous can explore <code>?setDadaOpt</code> for other adjustable algorithm parameters.
</div>
<div style="border: 1px solid blue;padding: 5px;background-color: #f0f0ff;;margin-top: 15px;">
<span style="color:blue"><strong>Extensions:</strong></span> By default, the <code>dada</code> function processes each sample independently. However, pooling information across samples can increase sensitivity to sequence variants that may be present at very low frequencies in multiple samples. The dada2 package offers two types of pooling. <code>dada(..., pool=TRUE)</code> performs <a href="pool.html">standard pooled processing, in which all samples are pooled together for sample inference</a>. <code>dada(..., pool="pseudo")</code> performs pseudo-pooling, in which <a href="pseudo.html#Pseudo-pooling">samples are processed independently after sharing information between samples, approximating pooled sample inference in linear time</a>.
</div>
<p> </p>
</div>
<div id="merge-paired-reads" class="section level1">
<h1>Merge paired reads</h1>
<p>We now merge the forward and reverse reads together to obtain the full denoised sequences. Merging is performed by aligning the denoised forward reads with the reverse-complement of the corresponding denoised reverse reads, and then constructing the merged “contig” sequences. By default, merged sequences are only output if the forward and reverse reads overlap by at least 12 bases, and are identical to each other in the overlap region (but these conditions can be changed via function arguments).</p>
<pre class="r"><code>mergers &lt;- mergePairs(dadaFs, filtFs, dadaRs, filtRs, verbose=TRUE)
# Inspect the merger data.frame from the first sample
head(mergers[[1]])</code></pre>
<pre><code>##                                                                                                                                                                                                                                                       sequence
## 1 TACGGAGGATGCGAGCGTTATCCGGATTTATTGGGTTTAAAGGGTGCGCAGGCGGAAGATCAAGTCAGCGGTAAAATTGAGAGGCTCAACCTCTTCGAGCCGTTGAAACTGGTTTTCTTGAGTGAGCGAGAAGTATGCGGAATGCGTGGTGTAGCGGTGAAATGCATAGATATCACGCAGAACTCCGATTGCGAAGGCAGCATACCGGCGCTCAACTGACGCTCATGCACGAAAGTGTGGGTATCGAACAGG
## 2 TACGGAGGATGCGAGCGTTATCCGGATTTATTGGGTTTAAAGGGTGCGTAGGCGGCCTGCCAAGTCAGCGGTAAAATTGCGGGGCTCAACCCCGTACAGCCGTTGAAACTGCCGGGCTCGAGTGGGCGAGAAGTATGCGGAATGCGTGGTGTAGCGGTGAAATGCATAGATATCACGCAGAACCCCGATTGCGAAGGCAGCATACCGGCGCCCTACTGACGCTGAGGCACGAAAGTGCGGGGATCAAACAGG
## 3 TACGGAGGATGCGAGCGTTATCCGGATTTATTGGGTTTAAAGGGTGCGTAGGCGGGCTGTTAAGTCAGCGGTCAAATGTCGGGGCTCAACCCCGGCCTGCCGTTGAAACTGGCGGCCTCGAGTGGGCGAGAAGTATGCGGAATGCGTGGTGTAGCGGTGAAATGCATAGATATCACGCAGAACTCCGATTGCGAAGGCAGCATACCGGCGCCCGACTGACGCTGAGGCACGAAAGCGTGGGTATCGAACAGG
## 4 TACGGAGGATGCGAGCGTTATCCGGATTTATTGGGTTTAAAGGGTGCGTAGGCGGGCTTTTAAGTCAGCGGTAAAAATTCGGGGCTCAACCCCGTCCGGCCGTTGAAACTGGGGGCCTTGAGTGGGCGAGAAGAAGGCGGAATGCGTGGTGTAGCGGTGAAATGCATAGATATCACGCAGAACCCCGATTGCGAAGGCAGCCTTCCGGCGCCCTACTGACGCTGAGGCACGAAAGTGCGGGGATCGAACAGG
## 5 TACGGAGGATGCGAGCGTTATCCGGATTTATTGGGTTTAAAGGGTGCGCAGGCGGACTCTCAAGTCAGCGGTCAAATCGCGGGGCTCAACCCCGTTCCGCCGTTGAAACTGGGAGCCTTGAGTGCGCGAGAAGTAGGCGGAATGCGTGGTGTAGCGGTGAAATGCATAGATATCACGCAGAACTCCGATTGCGAAGGCAGCCTACCGGCGCGCAACTGACGCTCATGCACGAAAGCGTGGGTATCGAACAGG
## 6 TACGGAGGATGCGAGCGTTATCCGGATTTATTGGGTTTAAAGGGTGCGTAGGCGGGATGCCAAGTCAGCGGTAAAAAAGCGGTGCTCAACGCCGTCGAGCCGTTGAAACTGGCGTTCTTGAGTGGGCGAGAAGTATGCGGAATGCGTGGTGTAGCGGTGAAATGCATAGATATCACGCAGAACTCCGATTGCGAAGGCAGCATACCGGCGCCCTACTGACGCTGAGGCACGAAAGCGTGGGTATCGAACAGG
##   abundance forward reverse nmatch nmismatch nindel prefer accept
## 1       579       1       1    148         0      0      1   TRUE
## 2       470       2       2    148         0      0      2   TRUE
## 3       449       3       4    148         0      0      1   TRUE
## 4       430       4       3    148         0      0      2   TRUE
## 5       345       5       6    148         0      0      1   TRUE
## 6       282       6       5    148         0      0      2   TRUE</code></pre>
<p>The <code>mergers</code> object is a list of <code>data.frame</code>s from each sample. Each <code>data.frame</code> contains the merged <code>$sequence</code>, its <code>$abundance</code>, and the indices of the <code>$forward</code> and <code>$reverse</code> sequence variants that were merged. Paired reads that did not exactly overlap were removed by <code>mergePairs</code>, further reducing spurious output.</p>
<div style="border: 1px solid red;padding: 5px;background-color: #fff6f6;">
<strong><span style="color:red">Considerations for your own data:</span></strong> Most of your <strong>reads</strong> should successfully merge. If that is not the case upstream parameters may need to be revisited: Did you trim away the overlap between your reads?
</div>
<div style="border: 1px solid blue;padding: 5px;background-color: #f0f0ff;;margin-top: 15px;">
<span style="color:blue"><strong>Extensions:</strong></span> Non-overlapping reads are supported, but not recommended, with <code>mergePairs(..., justConcatenate=TRUE)</code>.
</div>
<p> </p>
</div>
<div id="construct-sequence-table" class="section level1">
<h1>Construct sequence table</h1>
<p>We can now construct an amplicon sequence variant table (ASV) table, a higher-resolution version of the OTU table produced by traditional methods.</p>
<pre class="r"><code>seqtab &lt;- makeSequenceTable(mergers)
dim(seqtab)</code></pre>
<pre><code>## [1]  20 293</code></pre>
<pre class="r"><code># Inspect distribution of sequence lengths
table(nchar(getSequences(seqtab)))</code></pre>
<pre><code>## 
## 251 252 253 254 255 
##   1  88 196   6   2</code></pre>
<p>The sequence table is a <code>matrix</code> with rows corresponding to (and named by) the samples, and columns corresponding to (and named by) the sequence variants. This table contains 293 ASVs, and the lengths of our merged sequences all fall within the expected range for this V4 amplicon.</p>
<div style="border: 1px solid red;padding: 5px;background-color: #fff6f6;">
<strong><span style="color:red">Considerations for your own data:</span></strong> Sequences that are much longer or shorter than expected may be the result of non-specific priming. You can remove non-target-length sequences from your sequence table (eg. <code>seqtab2 &lt;- seqtab[,nchar(colnames(seqtab)) %in% 250:256]</code>). This is analogous to “cutting a band” in-silico to get amplicons of the targeted length.
</div>
<p> </p>
</div>
<div id="remove-chimeras" class="section level1">
<h1>Remove chimeras</h1>
<p>The core <code>dada</code> method corrects substitution and indel errors, but chimeras remain. Fortunately, the accuracy of sequence variants after denoising makes identifying chimeric ASVs simpler than when dealing with fuzzy OTUs. Chimeric sequences are identified if they can be exactly reconstructed by combining a left-segment and a right-segment from two more abundant “parent” sequences.</p>
<pre class="r"><code>seqtab.nochim &lt;- removeBimeraDenovo(seqtab, method=&quot;consensus&quot;, multithread=TRUE, verbose=TRUE)
dim(seqtab.nochim)</code></pre>
<pre><code>## [1]  20 232</code></pre>
<pre class="r"><code>sum(seqtab.nochim)/sum(seqtab)</code></pre>
<pre><code>## [1] 0.9640374</code></pre>
<p>The frequency of chimeric sequences varies substantially from dataset to dataset, and depends on on factors including experimental procedures and sample complexity. Here chimeras make up about 21% of the merged sequence variants, but when we account for the abundances of those variants we see they account for only about 4% of the merged sequence reads.</p>
<div style="border: 1px solid red;padding: 5px;background-color: #fff6f6;">
<strong><span style="color:red">Considerations for your own data:</span></strong> Most of your <strong>reads</strong> should remain after chimera removal (it is not uncommon for a majority of <strong>sequence variants</strong> to be removed though). If most of your reads were removed as chimeric, upstream processing may need to be revisited. In almost all cases this is caused by primer sequences with ambiguous nucleotides that were not removed prior to beginning the DADA2 pipeline.
</div>
<p> </p>
</div>
<div id="track-reads-through-the-pipeline" class="section level1">
<h1>Track reads through the pipeline</h1>
<p>As a final check of our progress, we’ll look at the number of reads that made it through each step in the pipeline:</p>
<pre class="r"><code>getN &lt;- function(x) sum(getUniques(x))
track &lt;- cbind(out, sapply(dadaFs, getN), sapply(dadaRs, getN), sapply(mergers, getN), rowSums(seqtab.nochim))
# If processing a single sample, remove the sapply calls: e.g. replace sapply(dadaFs, getN) with getN(dadaFs)
colnames(track) &lt;- c(&quot;input&quot;, &quot;filtered&quot;, &quot;denoisedF&quot;, &quot;denoisedR&quot;, &quot;merged&quot;, &quot;nonchim&quot;)
rownames(track) &lt;- sample.names
head(track)</code></pre>
<pre><code>##        input filtered denoisedF denoisedR merged nonchim
## F3D0    7793     7113      6976      6979   6540    6528
## F3D1    5869     5299      5227      5239   5028    5017
## F3D141  5958     5463      5331      5357   4986    4863
## F3D142  3183     2914      2799      2830   2595    2521
## F3D143  3178     2941      2822      2868   2553    2519
## F3D144  4827     4312      4151      4228   3646    3507</code></pre>
<p>Looks good! We kept the majority of our raw reads, and there is no over-large drop associated with any single step.</p>
<div style="border: 1px solid red;padding: 5px;background-color: #fff6f6;">
<strong><span style="color:red">Considerations for your own data:</span></strong> This is a great place to do a last <strong>sanity check</strong>. Outside of filtering, there should no step in which a majority of reads are lost. If a majority of reads failed to merge, you may need to revisit the <code>truncLen</code> parameter used in the filtering step and make sure that the truncated reads span your amplicon. If a majority of reads were removed as chimeric, you may need to revisit the removal of primers, as the ambiguous nucleotides in unremoved primers interfere with chimera identification.
</div>
<p> </p>
</div>
<div id="assign-taxonomy" class="section level1">
<h1>Assign taxonomy</h1>
<p>It is common at this point, especially in 16S/18S/ITS amplicon sequencing, to assign taxonomy to the sequence variants. The DADA2 package provides a native implementation of the <a href="http://www.ncbi.nlm.nih.gov/pubmed/17586664">naive Bayesian classifier method</a> for this purpose. The <code>assignTaxonomy</code> function takes as input a set of sequences to be classified and a training set of reference sequences with known taxonomy, and outputs taxonomic assignments with at least <code>minBoot</code> bootstrap confidence.</p>
<p>We maintain <a href="training.html">formatted training fastas for the RDP training set, GreenGenes clustered at 97% identity, and the Silva reference database</a>, and additional trainings fastas suitable for protists and certain specific environments have been contributed. For fungal taxonomy, the General Fasta release files from the <a href="https://unite.ut.ee/repository.php">UNITE ITS database</a> can be used as is. To follow along, download the <code>silva_nr99_v138.1_train_set.fa.gz</code> file, and place it in the directory with the fastq files.</p>
<pre class="r"><code>taxa &lt;- assignTaxonomy(seqtab.nochim, &quot;~/tax/silva_nr99_v138.1_train_set.fa.gz&quot;, multithread=TRUE)</code></pre>
<div style="border: 1px solid blue;padding: 5px;background-color: #f0f0ff;margin-top:30px;margin-bottom: 15px;">
<p><span style="color:blue"><strong>Extensions:</strong></span> The dada2 package also implements a method to make <a href="assign.html#species-assignment">species level assignments based on <strong>exact matching</strong></a> between ASVs and sequenced reference strains. Recent analysis suggests that <a href="https://academic.oup.com/bioinformatics/advance-article-abstract/doi/10.1093/bioinformatics/bty113/4913809">exact matching (or 100% identity) is the only appropriate way to assign species to 16S gene fragments</a>. Currently, <a href="training.html">species-assignment training fastas are available for the Silva and RDP 16S databases</a>. To follow the optional species addition step, download the <code>silva_species_assignment_v138.1.fa.gz</code> file, and place it in the directory with the fastq files.</p>
<pre class="r"><code>taxa &lt;- addSpecies(taxa, &quot;~/tax/silva_species_assignment_v138.1.fa.gz&quot;)</code></pre>
</div>
<p>Let’s inspect the taxonomic assignments:</p>
<pre class="r"><code>taxa.print &lt;- taxa # Removing sequence rownames for display only
rownames(taxa.print) &lt;- NULL
head(taxa.print)</code></pre>
<pre><code>##      Kingdom    Phylum         Class         Order           Family          
## [1,] &quot;Bacteria&quot; &quot;Bacteroidota&quot; &quot;Bacteroidia&quot; &quot;Bacteroidales&quot; &quot;Muribaculaceae&quot;
## [2,] &quot;Bacteria&quot; &quot;Bacteroidota&quot; &quot;Bacteroidia&quot; &quot;Bacteroidales&quot; &quot;Muribaculaceae&quot;
## [3,] &quot;Bacteria&quot; &quot;Bacteroidota&quot; &quot;Bacteroidia&quot; &quot;Bacteroidales&quot; &quot;Muribaculaceae&quot;
## [4,] &quot;Bacteria&quot; &quot;Bacteroidota&quot; &quot;Bacteroidia&quot; &quot;Bacteroidales&quot; &quot;Muribaculaceae&quot;
## [5,] &quot;Bacteria&quot; &quot;Bacteroidota&quot; &quot;Bacteroidia&quot; &quot;Bacteroidales&quot; &quot;Bacteroidaceae&quot;
## [6,] &quot;Bacteria&quot; &quot;Bacteroidota&quot; &quot;Bacteroidia&quot; &quot;Bacteroidales&quot; &quot;Muribaculaceae&quot;
##      Genus         Species
## [1,] NA            NA     
## [2,] NA            NA     
## [3,] NA            NA     
## [4,] NA            NA     
## [5,] &quot;Bacteroides&quot; NA     
## [6,] NA            NA</code></pre>
<p>Unsurprisingly, the Bacteroidetes are well represented among the most abundant taxa in these fecal samples. Few species assignments were made, both because it is often not possible to make unambiguous species assignments from subsegments of the 16S gene, and because there is surprisingly little coverage of the indigenous mouse gut microbiota in reference databases.</p>
<div style="border: 1px solid red;padding: 5px;background-color: #fff6f6;">
<strong><span style="color:red">Considerations for your own data:</span></strong> If your reads do not seem to be appropriately assigned, for example lots of your bacterial 16S sequences are being assigned as <code>Eukaryota NA NA NA NA NA</code>, your reads may be in the opposite orientation as the reference database. Tell dada2 to try the reverse-complement orientation with <code>assignTaxonomy(..., tryRC=TRUE)</code> and see if this fixes the assignments. If using DECIPHER for taxonomy, try <code>IdTaxa (..., strand="both")</code>.
</div>
<div style="border: 1px solid green;padding: 5px;background-color: #f0fff0;margin-top:30px;margin-bottom: 15px;">
<p><span style="color:green"><strong>Alternatives:</strong></span> The recently developed <code>IdTaxa</code> taxonomic classification method is also available via <a href="https://bioconductor.org/packages/release/bioc/html/DECIPHER.html">the DECIPHER Bioconductor package</a>. The paper introducing the IDTAXA algorithm <a href="https://microbiomejournal.biomedcentral.com/articles/10.1186/s40168-018-0521-5">reports classification performance that is better than the long-time standard set by the naive Bayesian classifier</a>. Here we include a code block that allows you to use <code>IdTaxa</code> as a drop-in replacement for <code>assignTaxonomy</code> (and it’s faster as well!). Trained classifiers are available from <a href="http://DECIPHER.codes/Downloads.html" class="uri">http://DECIPHER.codes/Downloads.html</a>. Download the SILVA SSU r132 (modified) file to follow along.</p>
<pre class="r"><code>library(DECIPHER); packageVersion(&quot;DECIPHER&quot;)</code></pre>
<pre><code>## [1] &#39;2.26.0&#39;</code></pre>
<pre class="r"><code>dna &lt;- DNAStringSet(getSequences(seqtab.nochim)) # Create a DNAStringSet from the ASVs
load(&quot;~/tax/IDTaxa/SILVA_SSU_r138_2019.RData&quot;) # CHANGE TO THE PATH OF YOUR TRAINING SET
ids &lt;- IdTaxa(dna, trainingSet, strand=&quot;top&quot;, processors=NULL, verbose=FALSE) # use all processors
ranks &lt;- c(&quot;domain&quot;, &quot;phylum&quot;, &quot;class&quot;, &quot;order&quot;, &quot;family&quot;, &quot;genus&quot;, &quot;species&quot;) # ranks of interest
# Convert the output object of class &quot;Taxa&quot; to a matrix analogous to the output from assignTaxonomy
taxid &lt;- t(sapply(ids, function(x) {
        m &lt;- match(ranks, x$rank)
        taxa &lt;- x$taxon[m]
        taxa[startsWith(taxa, &quot;unclassified_&quot;)] &lt;- NA
        taxa
}))
colnames(taxid) &lt;- ranks; rownames(taxid) &lt;- getSequences(seqtab.nochim)</code></pre>
The <code>taxid</code> matrix from <code>IdTaxa</code> is a drop-in replacement for the <code>taxa</code> matrix from <code>assignTaxonomy</code>, simply set <code>taxa &lt;- taxid</code> to carry on using the <code>IdTaxa</code> assignments. Read more about <code>IdTaxa</code> and other useful tools at <a href="http://www2.decipher.codes/">the DECIPHER R package website</a>.
</div>
<p> </p>
</div>
<div id="evaluate-accuracy" class="section level1">
<h1>Evaluate accuracy</h1>
<p>One of the samples included here was a “mock community”, in which a mixture of 20 known strains was sequenced (this mock community is supposed to be 21 strains, but <em>P. acnes</em> is absent from the raw data). Reference sequences corresponding to these strains were provided in the downloaded zip archive. We return to that sample and compare the sequence variants inferred by DADA2 to the expected composition of the community.</p>
<p><strong>Evaluating DADA2’s accuracy on the mock community</strong>:</p>
<pre class="r"><code>unqs.mock &lt;- seqtab.nochim[&quot;Mock&quot;,]
unqs.mock &lt;- sort(unqs.mock[unqs.mock&gt;0], decreasing=TRUE) # Drop ASVs absent in the Mock
cat(&quot;DADA2 inferred&quot;, length(unqs.mock), &quot;sample sequences present in the Mock community.\n&quot;)</code></pre>
<pre><code>## DADA2 inferred 20 sample sequences present in the Mock community.</code></pre>
<pre class="r"><code>mock.ref &lt;- getSequences(file.path(path, &quot;HMP_MOCK.v35.fasta&quot;))
match.ref &lt;- sum(sapply(names(unqs.mock), function(x) any(grepl(x, mock.ref))))
cat(&quot;Of those,&quot;, sum(match.ref), &quot;were exact matches to the expected reference sequences.\n&quot;)</code></pre>
<pre><code>## Of those, 20 were exact matches to the expected reference sequences.</code></pre>
<p>This mock community contained <strong>20</strong> bacterial strains. DADA2 identified <strong>20</strong> ASVs all of which <strong>exactly</strong> match the reference genomes of the expected community members. The residual error rate after the DADA2 pipeline for this sample is <strong>0%</strong>.</p>
<p><strong>Here ends the DADA2 portion of the tutorial</strong>.</p>
<hr />
</div>
<div id="bonus-handoff-to-phyloseq" class="section level1">
<h1>Bonus: Handoff to phyloseq</h1>
<p>The <a href="https://joey711.github.io/phyloseq/">phyloseq R package is a powerful framework for further analysis of microbiome data</a>. We now demonstrate how to straightforwardly import the tables produced by the DADA2 pipeline into phyloseq. We’ll also add the small amount of metadata we have – the samples are named by the gender (G), mouse subject number (X) and the day post-weaning (Y) it was sampled (eg. GXDY).</p>
<p><strong>Import into phyloseq</strong>:</p>
<pre class="r"><code>library(phyloseq); packageVersion(&quot;phyloseq&quot;)</code></pre>
<pre><code>## [1] &#39;1.42.0&#39;</code></pre>
<pre class="r"><code>library(Biostrings); packageVersion(&quot;Biostrings&quot;)</code></pre>
<pre><code>## [1] &#39;2.66.0&#39;</code></pre>
<pre class="r"><code>library(ggplot2); packageVersion(&quot;ggplot2&quot;)</code></pre>
<pre><code>## [1] &#39;3.4.0&#39;</code></pre>
<pre class="r"><code>theme_set(theme_bw())</code></pre>
<p>We can construct a simple sample <code>data.frame</code> from the information encoded in the filenames. Usually this step would instead involve reading the sample data in from a file.</p>
<pre class="r"><code>samples.out &lt;- rownames(seqtab.nochim)
subject &lt;- sapply(strsplit(samples.out, &quot;D&quot;), `[`, 1)
gender &lt;- substr(subject,1,1)
subject &lt;- substr(subject,2,999)
day &lt;- as.integer(sapply(strsplit(samples.out, &quot;D&quot;), `[`, 2))
samdf &lt;- data.frame(Subject=subject, Gender=gender, Day=day)
samdf$When &lt;- &quot;Early&quot;
samdf$When[samdf$Day&gt;100] &lt;- &quot;Late&quot;
rownames(samdf) &lt;- samples.out</code></pre>
<p>We now construct a phyloseq object directly from the dada2 outputs.</p>
<pre class="r"><code>ps &lt;- phyloseq(otu_table(seqtab.nochim, taxa_are_rows=FALSE), 
               sample_data(samdf), 
               tax_table(taxa))
ps &lt;- prune_samples(sample_names(ps) != &quot;Mock&quot;, ps) # Remove mock sample</code></pre>
<p>It is more convenient to use short names for our ASVs (e.g. ASV21) rather than the full DNA sequence when working with some of the tables and visualizations from phyloseq, but we want to keep the full DNA sequences for other purposes like merging with other datasets or indexing into reference databases like <a href="http://www.earthmicrobiome.org/">the Earth Microbiome Project</a>. For that reason we’ll store the DNA sequences of our ASVs in the refseq slot of the phyloseq object, and then rename our taxa to a short string. That way, the short new taxa names will appear in tables and plots, and we can still recover the DNA sequences corresponding to each ASV as needed with <code>refseq(ps)</code>.</p>
<pre class="r"><code>dna &lt;- Biostrings::DNAStringSet(taxa_names(ps))
names(dna) &lt;- taxa_names(ps)
ps &lt;- merge_phyloseq(ps, dna)
taxa_names(ps) &lt;- paste0(&quot;ASV&quot;, seq(ntaxa(ps)))
ps</code></pre>
<pre><code>## phyloseq-class experiment-level object
## otu_table()   OTU Table:         [ 232 taxa and 19 samples ]
## sample_data() Sample Data:       [ 19 samples by 4 sample variables ]
## tax_table()   Taxonomy Table:    [ 232 taxa by 7 taxonomic ranks ]
## refseq()      DNAStringSet:      [ 232 reference sequences ]</code></pre>
<p>We are now ready to use phyloseq!</p>
<p><strong>Visualize alpha-diversity</strong>:</p>
<pre class="r"><code>plot_richness(ps, x=&quot;Day&quot;, measures=c(&quot;Shannon&quot;, &quot;Simpson&quot;), color=&quot;When&quot;)</code></pre>
<p><img src="tutorial_files/figure-html/richness-1.png" width="672" /></p>
<p>No obvious systematic difference in alpha-diversity between early and late samples.</p>
<p><strong>Ordinate</strong>:</p>
<pre class="r"><code># Transform data to proportions as appropriate for Bray-Curtis distances
ps.prop &lt;- transform_sample_counts(ps, function(otu) otu/sum(otu))
ord.nmds.bray &lt;- ordinate(ps.prop, method=&quot;NMDS&quot;, distance=&quot;bray&quot;)</code></pre>
<pre><code>## Run 0 stress 0.08043117 
## Run 1 stress 0.08076339 
## ... Procrustes: rmse 0.01051237  max resid 0.03235558 
## Run 2 stress 0.09477219 
## Run 3 stress 0.1228545 
## Run 4 stress 0.08043116 
## ... New best solution
## ... Procrustes: rmse 1.699413e-06  max resid 4.492512e-06 
## ... Similar to previous best
## Run 5 stress 0.1010631 
## Run 6 stress 0.08076339 
## ... Procrustes: rmse 0.01054992  max resid 0.0324765 
## Run 7 stress 0.08076339 
## ... Procrustes: rmse 0.01050059  max resid 0.03231325 
## Run 8 stress 0.1212044 
## Run 9 stress 0.08043116 
## ... Procrustes: rmse 8.180652e-07  max resid 1.741666e-06 
## ... Similar to previous best
## Run 10 stress 0.08076338 
## ... Procrustes: rmse 0.01053605  max resid 0.03243126 
## Run 11 stress 0.08616061 
## Run 12 stress 0.0807634 
## ... Procrustes: rmse 0.0105699  max resid 0.03254154 
## Run 13 stress 0.1212044 
## Run 14 stress 0.08616061 
## Run 15 stress 0.1256441 
## Run 16 stress 0.1336964 
## Run 17 stress 0.0947719 
## Run 18 stress 0.08043117 
## ... Procrustes: rmse 3.134295e-06  max resid 9.546557e-06 
## ... Similar to previous best
## Run 19 stress 0.09477214 
## Run 20 stress 0.08076337 
## ... Procrustes: rmse 0.0105016  max resid 0.03231875 
## *** Best solution repeated 3 times</code></pre>
<pre class="r"><code>plot_ordination(ps.prop, ord.nmds.bray, color=&quot;When&quot;, title=&quot;Bray NMDS&quot;)</code></pre>
<p><img src="tutorial_files/figure-html/ordinate-1.png" width="672" /></p>
<p>Ordination picks out a clear separation between the early and late samples.</p>
<p><strong>Bar plot</strong>:</p>
<pre class="r"><code>top20 &lt;- names(sort(taxa_sums(ps), decreasing=TRUE))[1:20]
ps.top20 &lt;- transform_sample_counts(ps, function(OTU) OTU/sum(OTU))
ps.top20 &lt;- prune_taxa(top20, ps.top20)
plot_bar(ps.top20, x=&quot;Day&quot;, fill=&quot;Family&quot;) + facet_wrap(~When, scales=&quot;free_x&quot;)</code></pre>
<p><img src="tutorial_files/figure-html/bar-plot-1.png" width="672" /></p>
<p>Nothing glaringly obvious jumps out from the taxonomic distribution of the top 20 sequences to explain the early-late differentiation.</p>
</div>
<div id="using-external-packages" class="section level1">
<h1>Using external packages</h1>
<p>A variety of other packages are available, extending phyloseq. Dr. Sudarshan Shetty maintains a comprehensive <a href="https://microsud.github.io/Tools-Microbiome-Analysis/">list of R tools for microbiome data science</a>. One widely used package is the <a href="https://bioconductor.org/packages/devel/bioc/html/microbiome.html">microbiome R/Bioconductor package</a>, which has a more extensive <a href="https://microbiome.github.io/tutorials/">tutorial</a> of its own. The package provides tools for microbiome data manipulation, transformations, and visualization.</p>
<p>Let us first load the package, and transform the original count data into relative abundances. Other common transformations are also available, including e.g. clr, hellinger, and log10p.</p>
<pre class="r"><code>library(microbiome)

# Transform into compositional data (relative abundances)
ps.rel &lt;- microbiome::transform(ps, &quot;compositional&quot;)</code></pre>
<p>Let us then calculate prevalence of the taxa (i.e. relative population frequencies), using 0.1% compositional abundance as a detection threshold:</p>
<pre class="r"><code># Sorted from the most prevalent to the least prevalent
head(prevalence(ps.rel, detection = 0.1/100, sort = TRUE), 20)</code></pre>
<pre><code>##     ASV18     ASV15     ASV14     ASV13     ASV11     ASV10      ASV9      ASV8 
## 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000 
##      ASV7      ASV5      ASV4      ASV3      ASV2      ASV1     ASV54     ASV40 
## 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000 0.9473684 0.9473684 
##     ASV28     ASV25     ASV21     ASV55 
## 0.9473684 0.9473684 0.9473684 0.8947368</code></pre>
<p>We can also subset the phyloseq object to the prevalent taxa (detected in 50% of the population at higher than 0.1% relative abundance):</p>
<pre class="r"><code># Subset to prevalent (core) taxa
ps.core &lt;- core(ps.rel, detection = 0.1/100, prevalence = 50/100)

# Compare the objects before and after subsetting to the core:
print(ps.rel)</code></pre>
<pre><code>## phyloseq-class experiment-level object
## otu_table()   OTU Table:         [ 232 taxa and 19 samples ]
## sample_data() Sample Data:       [ 19 samples by 4 sample variables ]
## tax_table()   Taxonomy Table:    [ 232 taxa by 7 taxonomic ranks ]
## refseq()      DNAStringSet:      [ 232 reference sequences ]</code></pre>
<pre class="r"><code>print(ps.core)</code></pre>
<pre><code>## phyloseq-class experiment-level object
## otu_table()   OTU Table:         [ 57 taxa and 19 samples ]
## sample_data() Sample Data:       [ 19 samples by 4 sample variables ]
## tax_table()   Taxonomy Table:    [ 57 taxa by 7 taxonomic ranks ]
## refseq()      DNAStringSet:      [ 57 reference sequences ]</code></pre>
<p>We can also aggregate data to Genus level, and collapse rare taxa into an “Other” category.</p>
<pre class="r"><code>ps.core2 &lt;- aggregate_rare(ps.rel, &quot;Genus&quot;, detection = 0.1/100, prevalence = 50/100)
print(ps.core2)</code></pre>
<pre><code>## phyloseq-class experiment-level object
## otu_table()   OTU Table:         [ 25 taxa and 19 samples ]
## sample_data() Sample Data:       [ 19 samples by 4 sample variables ]
## tax_table()   Taxonomy Table:    [ 25 taxa by 2 taxonomic ranks ]</code></pre>
<p>Finally, the microbiome package provides complementary visualization methods. One example is a heatmap that can be used to visualize relations between the size of the core microbiota at various detection and prevalence thresholds (<a href="https://academic.oup.com/femsre/article/doi/10.1093/femsre/fuw045/2979411/Intestinal-microbiome-landscaping-insight-in#58802539">Shetty et al. FEMS Microbiology Reviews fuw045, 2017</a>).</p>
<pre class="r"><code># Core with absolute counts and horizontal view:
# and minimum population prevalence (given as percentage)
# In the end we add some ggplot formatting for the figure
library(RColorBrewer)
prevalences &lt;- seq(.05, 1, .05)
detections &lt;- seq(from = 0, to = round(max(abundances(ps.rel))/10, 2), by = 0.002)
p &lt;- plot_core(ps.rel, plot.type = &quot;heatmap&quot;,
               prevalences = prevalences,
               detections = detections,
               colours = rev(brewer.pal(5, &quot;Spectral&quot;)),
               min.prevalence = .2, horizontal = TRUE) +
  theme(axis.text.x= element_text(size=8, face=&quot;italic&quot;, hjust=1),
        axis.text.y= element_text(size=8),
        axis.title = element_text(size=10),
        legend.text = element_text(size=8),
        legend.title = element_text(size=10))
print(p)</code></pre>
<p><img src="tutorial_files/figure-html/microbiomecoreheatmap-1.png" width="1440" /></p>
<p>These were some minimal examples of what can be done with phyloseq, as our purpose here was just to show how the results of DADA2 can be easily imported into phyloseq and interrogated further. For examples of the many analyses possible with phyloseq, see <a href="https://joey711.github.io/phyloseq/">the phyloseq web site</a>!</p>
</div>

<div class="container" style="width: 100%;color:grey;text-align:right">
  <hr>
  Maintained by Benjamin Callahan (benjamin DOT j DOT callahan AT gmail DOT com)
  <br> Documentation License: <a href="https://creativecommons.org/licenses/by/4.0">CC-BY 4.0</a>
</div>



</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
