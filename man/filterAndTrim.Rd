% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/filter.R
\name{filterAndTrim}
\alias{filterAndTrim}
\title{Filter and trim fastq file(s).}
\usage{
filterAndTrim(fwd, filt, rev = NULL, filt.rev = NULL, compress = TRUE,
  truncQ = 2, truncLen = 0, trimLeft = 0, maxLen = Inf, minLen = 20,
  maxN = 0, minQ = 0, maxEE = Inf, rm.phix = FALSE, matchIDs = FALSE,
  id.sep = "\\\\s", id.field = NULL, multithread = FALSE, n = 1e+05,
  OMP = TRUE, verbose = FALSE)
}
\arguments{
\item{fwd}{(Required). \code{character}.
The path(s) to the input fastq file(s).}

\item{filt}{(Required). \code{character}.
The path(s) to the output filtered file(s) corresponding to the \code{fwd} input files.
If containing directory does not exist, it will be created.}

\item{rev}{(Optional). Default NULL.
The path(s) to the input reverse fastq file(s) from paired-end sequence data corresponding to those
provided to the \code{fwd} argument. If NULL, the \code{fwd} files are processed as single-reads.}

\item{filt.rev}{(Optional). Default NULL, but required if \code{rev} is provided.
The path(s) to the output fastq file(s) corresponding to the \code{rev} input.
Can also provide a directory, which if not existing will be created (how to differentiate between dir/file in len1 case?).}

\item{compress}{(Optional). Default TRUE.
 If TRUE, the output fastq file(s) are gzipped.

\strong{FILTERING AND TRIMMING PARAMETERS ---------}   

\strong{Note:} When filtering paired reads...
If a length 1 vector is provided, the same parameter value is used for the forward and reverse reads.
If a length 2 vector is provided, the first value is used for the forward reads, and the second 
  for the reverse reads.}

\item{truncQ}{(Optional). Default 2.
Truncate reads at the first instance of a quality score less than or equal to \code{truncQ}.}

\item{truncLen}{(Optional). Default 0 (no truncation).
Truncate reads after \code{truncLen} bases. Reads shorter than this are discarded.}

\item{trimLeft}{(Optional). Default 0.
The number of nucleotides to remove from the start of each read. If both \code{truncLen} and 
\code{trimLeft} are provided, filtered reads will have length \code{truncLen-trimLeft}.}

\item{maxLen}{(Optional). Default Inf (no maximum).
Remove reads with length greater than maxLen. maxLen is enforced \strong{before} trimming and truncation.}

\item{minLen}{(Optional). Default 20.
Remove reads with length less than minLen. minLen is enforced \strong{after} trimming and truncation.}

\item{maxN}{(Optional). Default 0.
After truncation, sequences with more than \code{maxN} Ns will be discarded. 
Note that \code{\link{dada}} does not allow Ns.}

\item{minQ}{(Optional). Default 0.
After truncation, reads contain a quality score less than \code{minQ} will be discarded.}

\item{maxEE}{(Optional). Default \code{Inf} (no EE filtering).
After truncation, reads with higher than \code{maxEE} "expected errors" will be discarded.
Expected errors are calculated from the nominal definition of the quality score: EE = sum(10^(-Q/10))}

\item{rm.phix}{(Optional). Default FALSE.
If TRUE, discard reads that match against the phiX genome, as determined by \code{\link{isPhiX}}.}

\item{matchIDs}{(Optional). Default FALSE.
Whether to enforce matching between the id-line sequence identifiers of the forward and reverse fastq files.
  If TRUE, only paired reads that share id fields (see below) are output.
  If FALSE, no read ID checking is done.
Note: \code{matchIDs=FALSE} essentially assumes matching order between forward and reverse reads. If that
  matched order is not present future processing steps may break (in particular \code{\link{mergePairs}}).}

\item{id.sep}{(Optional). Default "\\s" (white-space).
The separator between fields in the id-line of the input fastq files. Passed to the \code{\link{strsplit}}.}

\item{id.field}{(Optional). Default NULL (automatic detection).
The field of the id-line containing the sequence identifier.
If NULL (the default) and matchIDs is TRUE, the function attempts to automatically detect
  the sequence identifier field under the assumption of Illumina formatted output.}

\item{multithread}{(Optional). Default is FALSE.
If TRUE, input files are filtered in parallel via \code{\link[parallel]{mclapply}}.
If an integer is provided, it is passed to the \code{mc.cores} argument of \code{\link[parallel]{mclapply}}.
Note that the parallelization here is by forking, and each process is loading another fastq file into
memory. If memory is an issue, execute in a clean environment and reduce the chunk size \code{n} and/or
the number of threads.}

\item{n}{(Optional). Default \code{1e5}.
The number of records (reads) to read in and filter at any one time. 
This controls the peak memory requirement so that very large fastq files are supported. 
See \code{\link{FastqStreamer}} for details.}

\item{OMP}{(Optional). Default TRUE.
Whether or not to use OMP multithreading when calling \code{\link{FastqStreamer}}. Set to FALSE if
calling this function within a parallelized chunk of code.
If \code{multithread=TRUE}, this argument will be coerced to FALSE.}

\item{verbose}{(Optional). Default FALSE.
Whether to output status messages.}
}
\value{
Integer matrix. Returned invisibly (i.e. only if assigned to something).
 Rows correspond to the input files, columns record the reads.in and reads.out after filtering.
}
\description{
Filters and trims an input fastq file(s) (can be compressed)
based on several user-definable criteria, and outputs fastq file(s)
(compressed by default) containing those trimmed reads which passed the filters. Corresponding
forward and reverse fastq file(s) can be provided as input, in which case filtering
is performed on the forward and reverse reads independently, and both reads must pass for
the read pair to be output.
}
\details{
\code{filterAndTrim} is a convenience interface for the \code{\link{fastqFilter}}
and \code{\link{fastqPairedFilter}} filtering functions, that handles multithreading.
Note that error messages and tracking are not handled gracefully when using the multithreading
functionality. If errors arise, it is recommended to re-run without multithreading to
troubleshoot the issue.
}
\examples{
testFastqs = c(system.file("extdata", "sam1F.fastq.gz", package="dada2"), system.file("extdata", "sam2F.fastq.gz", package="dada2"))
filtFastqs <- c(tempfile(fileext=".fastq.gz"), tempfile(fileext=".fastq.gz"))
filterAndTrim(testFastqs, filtFastqs, maxN=0, maxEE=2, verbose=TRUE)
filterAndTrim(testFastqs, filtFastqs, truncQ=2, truncLen=200, rm.phix=TRUE, multithread=2)

}
\seealso{
\code{\link{fastqFilter}}
 \code{\link{fastqPairedFilter}}
 \code{\link[ShortRead]{FastqStreamer}}
}
